<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shining</title>
  
  <subtitle>每个痛苦的时刻，都是成长的契机</subtitle>
  <link href="https://shininginfo.github.io/atom.xml" rel="self"/>
  
  <link href="https://shininginfo.github.io/"/>
  <updated>2022-06-25T14:59:06.537Z</updated>
  <id>https://shininginfo.github.io/</id>
  
  <author>
    <name>Shining</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础</title>
    <link href="https://shininginfo.github.io/2022/06/25/java%E5%9F%BA%E7%A1%80%20/"/>
    <id>https://shininginfo.github.io/2022/06/25/java%E5%9F%BA%E7%A1%80%20/</id>
    <published>2022-06-25T07:13:10.000Z</published>
    <updated>2022-06-25T14:59:06.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="static修饰成员变量的用法"><a href="#static修饰成员变量的用法" class="headerlink" title="static修饰成员变量的用法"></a>static修饰成员变量的用法</h2><ol><li><p>静态成员变量</p><p>所有对象都可以进行访问的变量，属于类的，只会存储一份，可以被共享访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="comment">//静态成员变量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String OnlineNumber;</span><br><span class="line"><span class="comment">//在类中访问静态成员变量可以省略类名不写</span></span><br><span class="line">  System.out.print(OnlineNumber);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问时可以使用类名进行访问</span></span><br><span class="line">User.OnlineNumber</span><br><span class="line"><span class="comment">//使用对象进行访问</span></span><br><span class="line">User user1=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user1.OnlineNumber<span class="comment">//不推荐</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>实例成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">  <span class="comment">//实例成员变量</span></span><br><span class="line">  <span class="keyword">private</span> Stringname;</span><br><span class="line">  <span class="comment">//实例成员变量不能直接在类里面访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问时只能使用对象来进行访问</span></span><br><span class="line">User user1=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user1.name</span><br></pre></td></tr></table></figure></li></ol><h2 id="static修饰成员变量的内存原理"><a href="#static修饰成员变量的内存原理" class="headerlink" title="static修饰成员变量的内存原理"></a>static修饰成员变量的内存原理</h2><p>静态成员变量是存放在<em><strong>堆内存</strong></em>之中，在类的静态变量区中存放。</p><h2 id="static修饰方法的基本用法"><a href="#static修饰方法的基本用法" class="headerlink" title="static修饰方法的基本用法"></a>static修饰方法的基本用法</h2><p>静态方法的使用场景：执行一个通用功能为目的</p><ol><li><p>静态成员方法</p><p>由static修饰，属于类，可以用类访问页可以用实例访问</p></li><li><p>实例成员方法</p><p>无static修饰，属于对象，只能用对象触发访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="comment">//静态成员方法的定义</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> a,intb)</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//实例方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//访问静态方法,可以用类名点，也可以用对象来点（不推荐）</span></span><br><span class="line">    Student.getMax(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//在同一个类中访问静态变量可以省略类名</span></span><br><span class="line">    getMax(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//访问实例方法</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    s1.study();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="static修饰方法的的内存原理"><a href="#static修饰方法的的内存原理" class="headerlink" title="static修饰方法的的内存原理"></a>static修饰方法的的内存原理</h2><p>静态方法会在方法区暴露出来，可以直接使用</p><p>实例方法会根据堆内存中对象的地址中找到方法引用的地址来进行方法的使用</p><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><p>一些应用程序中多次需要使用到的功能，可以将这些功能封装成静态方法，放在一个类中，这个类就是工具类。一次编写处处可用，<strong>建议将工具的构造器私有，不让工具类对外产生对象。</strong></p><p>因为工具类不要产生对象，同时也可以节约内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VerifyTools</span> &#123;</span><br><span class="line"><span class="comment">//工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">creatcode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">String data=<span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot;</span>;</span><br><span class="line">Random r=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">String code=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="type">int</span> index=r.nextInt(data.length());<span class="comment">//根据Code的长度随机生成一个索引号</span></span><br><span class="line"><span class="type">char</span> c=data.charAt(index);<span class="comment">//获取随机索引在Code中的字符</span></span><br><span class="line">code+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">VerifyTools</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//工具类不需要进行创造对象，可以节约内存</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static的注意事项"><a href="#static的注意事项" class="headerlink" title="static的注意事项"></a>static的注意事项</h2><ul><li>静态方法只能访问静态成员，不可以直接访问实例成员</li><li>实例方法可以访问静态成员，也可以访问实例成员</li><li>静态方法中是不可以出现this关键字的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> onlineNumber；</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.静态方法可以直接访问静态成员</span></span><br><span class="line">    System.out.println(onlineNumber);</span><br><span class="line">    System.out.println(Test.onlineNumber);</span><br><span class="line">    <span class="comment">//2.静态方法也可以访问静态方法</span></span><br><span class="line">    inAddr();</span><br><span class="line">    <span class="comment">//4.可以通过创建对象来访问实例方法</span></span><br><span class="line">    Test t=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">     System.out.println(t.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//3.实例方法可以直接访问静态成员,也可以访问实例成员</span></span><br><span class="line">    System.out.println(onlineNumber);</span><br><span class="line">    System.out.println(Test.onlineNumber);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    sing()；  </span><br><span class="line">   getMax();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;sing&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static修饰的代码块"><a href="#static修饰的代码块" class="headerlink" title="static修饰的代码块"></a>static修饰的代码块</h2><ul><li><p>静态代码块</p><p>格式：static{}</p><p>特点：随着类的加载而加载，并自动触发，只执行一次</p><p>使用场景：在类加载的时候做一些静态数据初始化的操作以便后续使用在程序加载时进行静态数据的初始化操作（准备内容）</p></li><li><p>构造代码块</p><p>格式：{}</p><p>特点：每次创建对象的时候调用构造器时，都会执行该代码块中的代码，并且在<strong>构造器之前执行</strong></p><p>使用场景：初始化实例资源</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;静态代码块执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造代码块</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;实例代码块执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">CodeBlock()&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造器触发&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;main方法执行&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">CodeBlock</span>();<span class="comment">//匿名对象</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//静态代码块执行    static的代码块优先执行</span></span><br><span class="line"><span class="comment">//main方法执行</span></span><br><span class="line"><span class="comment">//构造代码块执行   构造代码块优先执行，且每新建一个对象都会执行一次</span></span><br><span class="line"><span class="comment">//构造器触发</span></span><br></pre></td></tr></table></figure><h2 id="设计模式—1-单例模式"><a href="#设计模式—1-单例模式" class="headerlink" title="设计模式—1.单例模式"></a>设计模式—1.单例模式</h2><p>保证系统中，应用概莫司的这个类永远只有一个实例，即一个类永远只能创建一个对象。</p><h3 id="饿汉单例"><a href="#饿汉单例" class="headerlink" title="饿汉单例"></a>饿汉单例</h3><p>在用类获取对象的时候，对象已经提前为你创建好了</p><ol><li>定义一个单例类</li><li>单例必须私有构造器</li><li>定义一个静态变量存储一个对象即可：属于类，与类一起加载一次。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line"><span class="comment">//1.把构造器私有</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.定义一个公开的静态的成员变量存储一个类的对象</span></span><br><span class="line"><span class="comment">//加载静态变量的时候就已经创建好对象了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance instance=<span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SingleInstance s1=SingleInstance.instance;</span><br><span class="line">SingleInstance s2=SingleInstance.instance;</span><br><span class="line">System.out.println(s1==s2);<span class="comment">//true 地址一样</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉单例"><a href="#懒汉单例" class="headerlink" title="懒汉单例"></a>懒汉单例</h3><p>在真正需要该对象的时候才去创建一个对象（延迟加载对象）</p><ul><li>定义一个类，把构造器私有</li><li>定义一个静态变量存储一个对象</li><li>提供一个返回单例对象的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance2</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SingleInstance2</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个静态的成员变量存储类的对象，注意此时不能初始化对象</span></span><br><span class="line">  <span class="comment">//将变量私有化，别人就不能去点了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SingleInstance2instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个方法，让其他地方可以来调用获取一个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//第一次获取对象</span></span><br><span class="line">instance=<span class="keyword">new</span> <span class="title class_">SingleInstance2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承extends"><a href="#继承extends" class="headerlink" title="继承extends"></a>继承extends</h1><ul><li>继承是类与类之间的一种关系</li><li><strong>多个类继承单独的某个类</strong>，多个类就可以使用单独这个类的属性和行为了</li><li>多个类称为子类（派生类），单独的这个类称为父类（基类，超类）</li></ul><p>创建子类对象时，堆内存中对象的空间其实分为了父类空间（super）和子类空间（this），对应的属性在对应的空间中。</p><img src="C:\Users\shangshy\AppData\Roaming\Typora\typora-user-images\image-20220117170259850.png" alt="image-20220117170259850" style="zoom:67%;" /><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>子类可以继承父类的属性，但是子类不能继承父类的构造器</li><li>Java是单继承模式，一个类只能继承一个直接父类</li><li>Java不支持多继承，但是支持多层继承</li><li>Java中所有的类都是Object类的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Private_feature</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">//1.子类是否可以继承父类的私有属性和方法？继承了，只是不能直接访问</span></span><br><span class="line"><span class="comment">//s1.age;</span></span><br><span class="line"><span class="comment">//2.子类是否可以继承父类的静态成员？ 不继承，但是可以使用。子类可以直接使用父类的静态成员（共享）</span></span><br><span class="line"><span class="comment">//静态成员是属于父类的，内存中只有一份</span></span><br><span class="line">System.out.println(Student.online);</span><br><span class="line">Student.inAdd();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age=<span class="number">21</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;人在跑&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> online;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAdd</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;学习Java&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承后的访问特点"><a href="#继承后的访问特点" class="headerlink" title="继承后的访问特点"></a>继承后的访问特点</h2><p>在子类方法中访问成员（成员变量、成员方法）满足：<font color="red">就近原则</font></p><ul><li>先在子类局部范围找</li><li>然后子类成员范围找</li><li>然后父类成员范围找，如果父类范围还没有就报错</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name=<span class="string">&quot;父类名称&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name=<span class="string">&quot;子类名称&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ShowName</span><span class="params">()</span>&#123;</span><br><span class="line">    String name=<span class="string">&quot;局部名称&quot;</span>;</span><br><span class="line">    System.out.println(name);<span class="comment">//局部名称</span></span><br><span class="line">    System.out.println(<span class="built_in">this</span>.name);<span class="comment">//子类名称</span></span><br><span class="line">    System.out.println(<span class="built_in">super</span>.name);<span class="comment">//父类名称</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果子父类中，出现了重名的成员，会优先使用子类的，此时如果一定要在子类中使用父类的方法怎么办？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;父类的跑&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;子类的跑&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    s1.run();<span class="comment">//子类的跑</span></span><br><span class="line">    s1.go();<span class="comment">//父类的跑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>子类中出现了父类中一模一样的方法声明，子类就重写了父类的方法</p><p>@Override注解 是放在方法重后的方法上，作为重写是否正确的校验注解，加上该注解后如果出现重写错误，编译阶段会出现错误提示</p><p>要求：</p><ul><li>重写的方法名称、形参列表必须与被重写的方法和参数列表一致</li><li>私有方法不能被重写</li><li>子类重写父类方法时，访问权限必须大于或等于父类（缺省&lt;protected&lt;public）</li><li>子类不能重写父类的静态方法，如果重写会报错 （因为静态方法子类没有继承，所以不能重写。）</li></ul><h2 id="子类构造器的特点"><a href="#子类构造器的特点" class="headerlink" title="子类构造器的特点"></a>子类构造器的特点</h2><p>子类中所有的构造器默认都会先访问父类中的无参构造器再执行自己的。</p><ul><li>子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。</li><li>子类初始化之前，一定要调用父类构造器先完成父类数据空间的初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Cat c=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">Cat c1=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出 父类Anmial调用</span></span><br><span class="line"><span class="comment">子类cat调用</span></span><br><span class="line"><span class="comment">父类Anmial调用</span></span><br><span class="line"><span class="comment">子类cat有参构造器调用*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Anmial</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Anmial</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类Anmial调用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Anmial</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子类cat调用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子类cat有参构造器调用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>super调用父类有参构造器的作用？<ul><li>初始化继承自父类的数据</li></ul></li><li>如果父类中没有无参构造器，只有有参构造器会怎么样呢？<ul><li>会报错，因为子类默认调用父类的有参构造器</li></ul></li><li>子类通过this去调用本类的构造器，本类的其他构造器会通过super区手动调用父类的构造器，最终还是会调用父类的构造器的。</li><li>this和super都只能放在构造器的第一行，所以二者不能共存在同一个构造器中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String School;</span><br><span class="line">  Student(String name)&#123;</span><br><span class="line">    <span class="built_in">this</span>(name,<span class="string">&quot;学校名&quot;</span>);<span class="comment">//this关键字调用本类的构造器，这个不会调用父类的构造器</span></span><br><span class="line">  &#125;</span><br><span class="line">  Student(String name,String school)&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.School=school</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><ul><li><p>相同包下的类可以直接访问，不同包下的类必须导包才可以使用，格式：import 包名.类名</p></li><li><p>假如一个类中需要用到不同类，而这两个类的名称是一样的，那么默认只能导入一个包，另一个类要带包名访问。</p></li></ul><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>权限大小：private-&gt;缺省-&gt;protected-&gt;public</p><table><thead><tr><th>修饰符</th><th align="center">同一个类中</th><th align="center">不同包下的子类</th><th align="center">同一个包中其他类</th><th align="center">不同包下的无关类</th></tr></thead><tbody><tr><td>private</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>缺省</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td>protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td>public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><ul><li>成员变量一般私有</li><li>方法一般公开</li><li>如果该成员只希望被本类访问，用private</li><li>如果该成员只希望本类，同一个包下的其他类和子类访问用protected</li></ul><h1 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h1><ul><li><p>final修饰方法：表明该方法是最终方法，不能被重写</p></li><li><p>final修饰变量：表示该变量第一次赋值后，不能再次被赋值（有且仅有一次赋值机会）</p><p>变量：局部变量，成员变量（静态成员变量，实例成员变量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">( <span class="keyword">final</span> <span class="type">double</span> z)</span>&#123;</span><br><span class="line"><span class="comment">//这样z这个变量在方法执行的过程中就无法进行值的修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>final修饰类：表明该类是最终类，不能被继承</p><p>注：</p><ol><li>final修饰的变量是基本类型：那么变量存储的&#x3D;&#x3D;<font color="red">数据值</font>&#x3D;&#x3D;不能发生变化</li><li>final修饰的变量是引用类型：那么变量存储的&#x3D;&#x3D;<font color="red">地址值</font>&#x3D;&#x3D;不能发生变化，但是地址指向的对象内容是可以发生变化的。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> age=<span class="number">14</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] arr=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">arr[<span class="number">2</span>]=<span class="number">40</span>;<span class="comment">//是可以的，只是修改了arr里面的内容</span></span><br><span class="line"><span class="comment">//arr=null这个是不对的相当于重新赋值了，修改了他的地址</span></span><br></pre></td></tr></table></figure><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>使用public static final修饰的成员变量，必须有初始化值，且在执行过程中其值不能被改变。</p><p>命名规范：英文单词全部大写，多个单词下划线连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHOOL_NAME=<span class="string">&quot;XX学校&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>用于做信息标志和信息分类</p><p>枚举的定义格式：</p><p>修饰符 enum 枚举名称{</p><p>​第一行都是罗列枚举类实例的名称</p><p>}</p><p><img src="C:\Users\shangshy\AppData\Roaming\Typora\typora-user-images\image-20220118174525575.png" alt="image-20220118174525575"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line"><span class="comment">//枚举类的对象名称</span></span><br><span class="line">SPRING,SUMMER,AUTUMN,WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象类必须要用abstract修饰。修饰符 abstract class 类名()</p><ul><li>一个类如果继承了抽象类，那么这个类必须重写抽象类的全部抽象方法，否则这个类页必须定义为抽象类</li><li>可以被子类继承、充当末班，同时可以提高代码复用</li></ul><p>抽象方法：</p><ul><li><p>只有方法签名，没有方法体，是由abstract修饰</p><p>修饰符 abstract 返回值类型 方法名（形参列表）；</p></li></ul><h2 id="抽象类的特点："><a href="#抽象类的特点：" class="headerlink" title="抽象类的特点："></a>抽象类的特点：</h2><ol><li>抽象类不能创建对象。</li><li>抽象类也有成员变量、方法、构造器</li><li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>一个类继承了抽象类，就必须重写抽象方法否则也要定义为抽象方法</li><li>不能用abstract修饰变量、代码块、构造器</li></ol><h2 id="final和abstract的关系"><a href="#final和abstract的关系" class="headerlink" title="final和abstract的关系"></a>final和abstract的关系</h2><ul><li><p>互斥关系</p></li><li><p>final修饰类，类不能被继承。abstract修饰类，作为类模板被子类继承</p></li><li><p>抽象方法一定要被子类重写，final修饰方法不能被子类重写</p></li></ul><h2 id="设计模式—2-模板方法模式"><a href="#设计模式—2-模板方法模式" class="headerlink" title="设计模式—2.模板方法模式"></a>设计模式—2.模板方法模式</h2><p>场景说明：当系统中出现同一个功能在多处被开发，而该功能中大部分代码是一样的，只有其中部分可能不同的时候。</p><p>&#x3D;&#x3D;<font color=red>模板方法建议使用final修饰，是给子类直接使用的，不是让子类重写的。</font>&#x3D;&#x3D;</p><p>模板方法的实现步骤：</p><ol><li>把功能定义成一个所谓的模板方法，放在抽象类中，模板方法中只定义通用且能确定的代码。</li><li>模板方法中不能决定的功能定义成抽象方法让具体子类去实现。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">cal</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//不同账户（活期/定期）处理利息的方法不同，只用将这个定义成抽象方法即可</span></span><br><span class="line"><span class="comment">//子类只用重写cal这个抽象方法就可以了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String LoginName,String PassWord)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;itheima&quot;</span>.equals(LoginName) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(PassWord)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line"><span class="comment">//计算根据不同的账户（定期/活期）进行计算</span></span><br><span class="line"><span class="type">double</span> result=cal();</span><br><span class="line">System.out.println(<span class="string">&quot;本账户利息是&quot;</span>+result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;账户密码错误！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是体现规范的，其中用抽象方法定义的一组行为规范，接口是更加彻底的抽象</p><p>接口的格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">  <span class="comment">//常量</span></span><br><span class="line">  <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red>Notice：</font></p><ul><li>jdk8之前接口中只有抽象方法和常量，没有其他成分了</li><li>接口不能实例化</li><li>接口中的成员都是public修饰，写不写都是，因为规范的目的就是为了公开化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SportMan_Interface</span> &#123;</span><br><span class="line"><span class="comment">//jdk1.8之前只有 常量 和 抽象方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.常量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHOOL_NAME=<span class="string">&quot;XX学校&quot;</span>;</span><br><span class="line"><span class="comment">//其中public static final可以省略不写</span></span><br><span class="line">String SCHOOL_NAME1=<span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//其中public abstract可以省略不写</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>接口是用来被实现（implements）的，实现接口的类称为实现类，实现类可以理解为接口类的子类。</p><p>&#x3D;&#x3D;<font color=red>接口可以被类单实现，也可以被类多实现</font>&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 实现类 implements 接口1,接口2,..&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\shangshy\AppData\Roaming\Typora\typora-user-images\image-20220119160443627.png" alt="image-20220119160443627"></p><p><font color=red>Notice：</font></p><p>一个类实现接口，必须重写完全部接口的全部抽象方法，否则这个类需要定义为抽象类</p><h2 id="接口与接口关系-多继承"><a href="#接口与接口关系-多继承" class="headerlink" title="接口与接口关系-多继承"></a>接口与接口关系-多继承</h2><ul><li>规范合并，整合多个接口为一个接口，便于子类实现</li></ul><p>两个接口中某一个抽象方法名，返回值、参数列表相同时才能多继承。如果返回值不同则不能多继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Law</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">rule</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pingpong</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> interfacre people <span class="keyword">extends</span> <span class="title class_">Pingpong</span>,Law&#123;</span><br><span class="line">  <span class="comment">//虽然继承的两个接口都有run这个抽象方法，但是他们的返回值，参数列表都相同才能进行多继承。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK8之后接口新增方法"><a href="#JDK8之后接口新增方法" class="headerlink" title="JDK8之后接口新增方法"></a>JDK8之后接口新增方法</h2><p>允许接口中直接定义带有方法体的方法</p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><ul><li><p>类似之前写的普通实例方法，必须用default修饰</p></li><li><p>默认会加public修饰，需要用接口的实现类的对象来调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JDK_interface</span> &#123;</span><br><span class="line"><span class="comment">//1.默认方法（实例方法）</span></span><br><span class="line"><span class="comment">//只能用实现类来调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;跑得快&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pingponman</span> <span class="keyword">implements</span> <span class="title class_">JDK_interface</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">pingponman p=<span class="keyword">new</span> <span class="title class_">pingponman</span>();</span><br><span class="line">p.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li>默认会加public修饰，必须static修饰</li><li>&#x3D;&#x3D;<font color=red>接口的静态方法必须用本身的接口名来调用</font>&#x3D;&#x3D;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JDK_interface</span> &#123;</span><br><span class="line"><span class="comment">//2.静态方法</span></span><br><span class="line"><span class="comment">//必须使用接口名自己调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;学习java&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">JDK_interface.inAddr();<span class="comment">//调用</span></span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><ul><li>就是私有的实例方法，必须使用private修饰，从jdk1.9开始有的</li><li>只能在本类中被其他默认方法或私有方法访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JDK_interface</span> &#123;</span><br><span class="line"><span class="comment">//1.默认方法（实例方法）</span></span><br><span class="line"><span class="comment">//只能用实现类来调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;跑得快&quot;</span>);</span><br><span class="line">go();<span class="comment">//私有方法只能被类中的默认方法和私有方法调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.私有方法</span></span><br><span class="line"><span class="comment">//只能在接口中访问</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;go~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用接口的注意事项"><a href="#使用接口的注意事项" class="headerlink" title="使用接口的注意事项"></a>使用接口的注意事项</h2><ul><li><p>接口不能被创建对象</p></li><li><p>一个类实现多个接口，多个接口中同样的静态方法不冲突</p><p>因为实现的时候静态方法只能用接口名去调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notice_2</span> <span class="keyword">implements</span> <span class="title class_">A</span>,B &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">A.run();<span class="comment">//实现类调用接口静态方法同名不冲突</span></span><br><span class="line">B.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认使用父类的</p><p>​因为父类更近，先继承再实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notice_3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Cat cat=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">cat.eat();  <span class="comment">//输出 父类的吃！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span>&#123;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;默认方法的吃！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类的吃！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">C</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个类实现了多个接口，多个接口中存在同名的默认方法，不冲突，这个类重写该方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BB</span>&#123;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CC</span> <span class="keyword">implements</span> <span class="title class_">AA</span>,BB&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承</p></li></ul><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>同类型的对象，执行同一个行为会表现出不同的行为特征</p><p>常见形式：</p><ul><li>父类类型 对象名称&#x3D;new 子类构造器</li><li>接口 对象名称&#x3D;new 实现类构造器</li></ul><p>方法调用：编译看左边，运行看右边。</p><p>变量调用：编译看左边，运行也看左边</p><p>&#x3D;&#x3D;<font color=red>多态情况下不能使用子类的独有功能</font>&#x3D;&#x3D;</p><p>自动类型转换&#x3D;&#x3D;<font color=red>从子到父</font>&#x3D;&#x3D;：子类对象赋值给父类类型的变量指向</p><p>强制类型转换&#x3D;&#x3D;<font color=red>从父到子</font>&#x3D;&#x3D;：子类   对象名称&#x3D;（子类）父类类型的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//自动类型转换</span></span><br><span class="line">Animal a=<span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">a.run();</span><br><span class="line"></span><br><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line">Animal a2=<span class="keyword">new</span> <span class="title class_">Tortoise</span>();</span><br><span class="line">a2.run();</span><br><span class="line">Tortoise t=(Tortoise) a2;<span class="comment">//强制转换</span></span><br><span class="line">t.layEggs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;Notice&#x3D;&#x3D;：如果转型后的类型和对象的真实类型不是同一种类型，那么在转换的时候就会出现报错！！！</p><p>强制类型转换，有继承或者实现关系编译阶段可以强制类型转换，运行时会出错！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal t=<span class="keyword">new</span> <span class="title class_">Tortoise</span>();</span><br><span class="line">Dog d=(Dog) t;<span class="comment">//不能这样进行强制类型转换</span></span><br></pre></td></tr></table></figure><p><font color=red>java建议间址转换前使用instanceof判断当前对象的真实类型，再进行强制转换</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(t instanceof Dog)&#123;</span><br><span class="line">Dog d=(Dog) t;</span><br><span class="line">&#125;</span><br><span class="line">else if(t instanceof Tortoise)&#123;</span><br><span class="line">Tortoise d=(Tortoise) t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>就是定义在一个类里面的类，里面的类可以理解成（寄生），外部类可以理解为（宿主）</p><p>&#x3D;&#x3D;内部类通常可以方便访问外部类的成员，包括私有成员&#x3D;&#x3D;</p><p>内部类提供了更好的封装性，内部类本身就可以用private、protected等修饰，封装性可以做更多控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="comment">//内部类可以用private来修饰</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部的分类：</p><ul><li><p>静态内部类</p><p>由static修饰，属于外部类本身。它的特点和适应与普通类是完全一样的，类有的成分它都有，只有位置在别人里面而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String key;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//内部类的访问外部类.内部类.变量/方法</span></span><br><span class="line">    Outer.Inner.key=<span class="string">&quot;钥匙&quot;</span>;</span><br><span class="line">System.out.println(Outer.Inner.key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​&#x3D;&#x3D;Notice：&#x3D;&#x3D;</p><p>​静态内部类中可以直接访问外部类的静态成员，外部类的静态成员只有一份可以共享访问。</p><p>​静态内部类不可以直接访问外部类的实例成员，外部类的实例成员必须要用对象访问。但是可以间接访问，新建一个外部类的对象类进行访问</p><p>​</p></li><li><p>成员内部类</p><p>​无static修饰，属于外部类的对象。创建对象的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部类名.内部类名 对象名=new 外部类构造器().new 内部类构造器();</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;Notice&#x3D;&#x3D;</p><p>成员内部类中可以直接访问外部类的静态成员</p><p>成员内部类的实例方法&#x3D;&#x3D;可以&#x3D;&#x3D;直接访问外部类的实例成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> key=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Outer.Inner in=<span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">in.show();  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>局部内部类</p></li><li><p>匿名内部类</p><p>本质上是一个没有名字的局部内部类，定义在方法中、代码块中等。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**new 类|抽象类名|接口名（）&#123;</span></span><br><span class="line"><span class="comment">重写方法;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">Employee a=<span class="keyword">new</span> <span class="title class_">Employee</span>()&#123;</span><br><span class="line">  <span class="comment">//匿名内部类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anonymous</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="comment">//匿名内部类，可以省略建一个子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//重写抽象方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;老虎跑的快&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;特点&#x3D;&#x3D;：内部类写出来就会产生一个匿名内部类的对象。</p></li></ul><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式可以用一些规定的字符来制定规则，并用来校验数据格式的合法。</p><p>1.字符类</p><p><img src="C:\Users\shangshy\AppData\Roaming\Typora\typora-user-images\image-20220130190437257.png" alt="image-20220130190437257"></p><p>2.预定义的字符类</p><p><img src="C:\Users\shangshy\AppData\Roaming\Typora\typora-user-images\image-20220130190615950.png" alt="image-20220130190615950"></p><p>3.贪婪的量词，匹配多个字符</p><p><img src="C:\Users\shangshy\AppData\Roaming\Typora\typora-user-images\image-20220130190716912.png" alt="image-20220130190716912"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.只能是a，b,c</span></span><br><span class="line">   System.out.println(<span class="string">&quot;只能是a，b,c&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>));<span class="comment">//true</span></span><br><span class="line">   System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.不能出现 a b c</span></span><br><span class="line">   System.out.println(<span class="string">&quot;不能出现 a b c&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>));<span class="comment">//false</span></span><br><span class="line">   System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.数字的匹配</span></span><br><span class="line">   System.out.println(<span class="string">&quot;数字的匹配&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>));<span class="comment">//false</span></span><br><span class="line">   System.out.println(<span class="string">&quot;3&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>));<span class="comment">//true</span></span><br><span class="line">   System.out.println(<span class="string">&quot;333&quot;</span>.matches(<span class="string">&quot;\\s&quot;</span>));<span class="comment">//false</span></span><br><span class="line">   System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;\\S&quot;</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.校验密码   必须是数字、字母、下划线 至少6位</span></span><br><span class="line">   System.out.println(<span class="string">&quot;必须是数字、字母、下划线 至少6位&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;ssds3c&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>));<span class="comment">//true</span></span><br><span class="line">   System.out.println(<span class="string">&quot;ssdc&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>));<span class="comment">//false</span></span><br><span class="line">   System.out.println(<span class="string">&quot;ss435你dc&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//5.必须是数字、字母必须6位</span></span><br><span class="line">   System.out.println(<span class="string">&quot;23dfef&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));<span class="comment">//true</span></span><br><span class="line">   System.out.println(<span class="string">&quot;23d_Ffef&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));<span class="comment">//false</span></span><br><span class="line">   System.out.println(<span class="string">&quot;23d4&quot;</span>.matches(<span class="string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));<span class="comment">//true</span></span><br><span class="line">   System.out.println(<span class="string">&quot;23_4&quot;</span>.matches(<span class="string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String name=<span class="string">&quot;xiaklsjafklaj小路hlfjla蓉儿jslkajf&quot;</span>;</span><br><span class="line">        <span class="comment">//切割</span></span><br><span class="line">        String[] arr = name.split(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//替换</span></span><br><span class="line">        String name1=<span class="string">&quot;xiaklsjafklaj小路hlfjla蓉儿jslkajf&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> name1.replaceAll(<span class="string">&quot;\\w+&quot;</span>, <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        System.out.println(name2);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; title=&quot;static&quot;&gt;&lt;/a&gt;static&lt;/h1&gt;&lt;h2 id=&quot;static修饰成员变量的用法&quot;&gt;&lt;a href=&quot;#static修饰成员变量的用法&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://shininginfo.github.io/2022/06/25/Spring/"/>
    <id>https://shininginfo.github.io/2022/06/25/Spring/</id>
    <published>2022-06-25T07:13:10.000Z</published>
    <updated>2022-06-25T14:41:27.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h1><ul><li><p>Spring是轻量级的开源的JavaEE框架</p></li><li><p>Spring可以解决企业应用开发的复杂性</p></li><li><p>Spring有两个核心部分：IOC和AOP</p><ul><li><p>IOC：控制反转</p><p>把创建对象过程交给Spring进行管理</p></li><li><p>AOP：面向切面</p><p>不修改源代码进行功能增强</p></li></ul></li><li><p>Spring特点</p><ul><li>方便解耦，简化开发</li><li>AOP编程支持</li><li>方便程序测试</li><li>方便和其他框架进行整合</li><li>方便进行事务操作</li><li>降低API开发难度</li></ul></li></ul><h1 id="Spring快速入门"><a href="#Spring快速入门" class="headerlink" title="Spring快速入门"></a>Spring快速入门</h1><h2 id="Spring程序开发步骤"><a href="#Spring程序开发步骤" class="headerlink" title="Spring程序开发步骤"></a>Spring程序开发步骤</h2><ol><li><p>导入spring开发的基本包左边</p></li><li><p>编写dao接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//userDao接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类userDaoImpl 用于实现userdao的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建spring核心配置文件(applicationContext)</p></li><li><p>在spring配置文件中配置UserDaoImpl</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用spring的api获取bean实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoDemo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//获取IOC容器</span></span><br><span class="line">    ApplicationContext app=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//从容器中获取对象进行方法调用</span></span><br><span class="line">    UserDao userDao=(UserDao)app.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">    userDao.save();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h2><h3 id="Bean标签的基本配置"><a href="#Bean标签的基本配置" class="headerlink" title="Bean标签的基本配置"></a>Bean标签的基本配置</h3><p>​用于配置对象交由Spring来创建，默认情况下它调用的是类中<font color="red"><strong>无参构造函数</strong></font>，如果没有无参构造函数则不能创建成功</p><p>基本属性：</p><ul><li>id：Bean实例在spring容器中的唯一标识</li><li>class：Bean的全限定名称（包名+类型名）</li></ul><h3 id="Bean标签范围配置"><a href="#Bean标签范围配置" class="headerlink" title="Bean标签范围配置"></a>Bean标签范围配置</h3><p>scope：指对象的取值范围，取值如下</p><table><thead><tr><th align="left">取值范围</th><th>说明</th></tr></thead><tbody><tr><td align="left"><font color="red"><strong>singleton</strong></font></td><td>默认值，单例的</td></tr><tr><td align="left"><font color="red"><strong>prototype</strong></font></td><td>多例的</td></tr><tr><td align="left">request</td><td>Web项目中，Spring创建一个bean的对象，将对象存入request域中</td></tr><tr><td align="left">session</td><td>Web项目中，Spring创建一个bean的对象，将对象存入session域中</td></tr><tr><td align="left">global session</td><td>Web项目中，应用在Portlet环境，如果没有Portlet环境那么global session相当于session</td></tr></tbody></table><p>每次使用getBean时singleton只会创建一个对象，而prototype每次都会创建一个新的对象。</p><ul><li><strong>singleton</strong><ul><li>实例化个数：1个</li><li>实例化时机：当spring核心文件被加载时，实例化配置的Bean实例</li><li>Bean的生命周期：<ul><li>创建：当应用被加载，创建容器时，对象就被创建了</li><li>运行：只要容器在，对象一直活着</li><li>销毁：当应用卸载，销毁容器时，对象就被销毁了</li></ul></li></ul></li><li><strong>prototype</strong><ul><li>实例化个数：多个</li><li>实例化时机：当调用getBean方法被调用时</li><li>Bean的生命周期：<ul><li>创建：当使用对象时，创建新的对象实例</li><li>运行：只要对象在使用中，就一直活着</li><li>销毁：当对象长期不使用时，被Java的垃圾回收机制回收了</li></ul></li></ul></li></ul><h3 id="Bean生命周期配置"><a href="#Bean生命周期配置" class="headerlink" title="Bean生命周期配置"></a>Bean生命周期配置</h3><ul><li>init-method：是指类中的初始化方法名称</li><li>destory-method：是指类中销毁方法名称</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Dao.impl.UserDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean实例化的三种方式"><a href="#Bean实例化的三种方式" class="headerlink" title="Bean实例化的三种方式"></a>Bean实例化的三种方式</h3><ul><li><p><font color="red"><strong>无参构造</strong></font>方法实例化</p></li><li><p>工厂<font color="red"><strong>静态</strong></font>方法实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFactory</span> &#123;</span><br><span class="line">  <span class="comment">//用静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--class相当于找工厂的全限定名称 factory-method是指静态工厂中对应userDao的方法名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.factory.StaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>工厂<font color="red"><strong>实例</strong></font>方法实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicFactory</span>&#123;</span><br><span class="line">  <span class="comment">//不用静态方法，因为需要先有工厂对象，再去调用方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--factort-bean表示工厂bean的id  factory-method表示工厂中的方法名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.factory.DynamicFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Bean依赖注入"><a href="#Bean依赖注入" class="headerlink" title="Bean依赖注入"></a>Bean依赖注入</h3><p><font color="red"><strong>依赖注入</strong></font>：Spring框架核心IOC的具体实现。在编写程序时，通过控制反转，把对象的创建交给了spring，但是代码中不可能出现没有依赖的情况。IOC解耦只是降低了他们的依赖关系，但不会消除。eg：业务层（service）仍会调用持久层（dao）的方法。把业务层和持久层之间的依赖关系交给spring来维护。</p><p>​UserDao跟UserService都在Spring容器中，而最终程序直接使用的是UserService，所以可以在Spring容器中将UserDao设置到UserService内部。</p><ul><li><font color="red"><strong>set方法</strong></font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//set方法进行依赖注入-》从容器中注入依赖</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">    userDao.save();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--name是指set方法名中set后面的名称（UserDao）并且将第一个字母小写；ref是指引用那个bean使用id名，因为是唯一标识--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userdao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>p命名空间注入，就是省略property子标签。但是需要引入p命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Service.impl.UserServiceImpl&quot;</span> <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><font color="red"><strong>构造方法</strong></font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">      userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xm配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- name是指有参构造的参数名。ref是指引用的那个bean的id --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注入数据的三种数据类型</p><ul><li><p>普通数据类型 </p><p>同样可以用set方法和构造方法进行数据的注入</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;24&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>引用数据类型</li><li>集合数据类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; strList;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, User&gt; userMap;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrList</span><span class="params">(List&lt;String&gt; strList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strList = strList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserMap</span><span class="params">(Map&lt;String, User&gt; userMap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMap = userMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!--对user类中的name和age进行数据注入，可以创建两个对象根据id进行区分--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.domain.User&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tom&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;北京&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.domain.User&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lucy&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上海&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对userDao进行数据注入--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;strList&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--property中有list标签对list进行数据注入--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!--直接在value中输入值就行--&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">value</span>&gt;</span>bb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">value</span>&gt;</span>cc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--key对应的是字符串，value对应的是user类，因此使用ref引用--&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--prop中只有key的属性，对应的value写在标签中即可--&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>qqqq<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>qbbb<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="引入其他配置文件（分模块开发）"><a href="#引入其他配置文件（分模块开发）" class="headerlink" title="引入其他配置文件（分模块开发）"></a>引入其他配置文件（分模块开发）</h3><p>可以将部分配置拆解到其他配置文件中，在spring主配置文件通过import标签进行加载</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-xxx.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring相关API"><a href="#Spring相关API" class="headerlink" title="Spring相关API"></a>Spring相关API</h2><h3 id="ApplicationContext的实现类"><a href="#ApplicationContext的实现类" class="headerlink" title="ApplicationContext的实现类"></a>ApplicationContext的实现类</h3><ul><li><p>ClassPathXmlApplicationContext</p><p>从类的根路径下加载配置文件推荐使用这种</p></li><li><p>FileSystemXmlApplicationContext</p></li></ul><p>​从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置</p><ul><li>AnnotationConfigApplicationContext</li></ul><p>​当使用注解配置容器对象时，需要使用此类来创建spring容器，它用来读取注解。</p><h3 id="getBean-方法使用"><a href="#getBean-方法使用" class="headerlink" title="getBean()方法使用"></a>getBean()方法使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数是String，用的bean的id名称。允许配置文件中出现相同的类型（class属性相同）的bean，可以根据id来进行识别</span></span><br><span class="line"> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) app.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"><span class="comment">//参数是bean的类型，不用进行强制转换。这种就不允许配置文件中有相同类型的bean</span></span><br><span class="line"> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> app.getBean(UserService.class);</span><br></pre></td></tr></table></figure><h1 id="Spring配置数据源"><a href="#Spring配置数据源" class="headerlink" title="Spring配置数据源"></a>Spring配置数据源</h1><h2 id="数据源的作用"><a href="#数据源的作用" class="headerlink" title="数据源的作用"></a>数据源的作用</h2><ul><li>数据源是为提高程序性能而出现的</li><li>事先实例化数据源，初始化部分连接资源</li><li>使用连接资源时从数据源中获取</li><li>使用完毕后将连接资源归还给数据源</li></ul><h2 id="数据源的开发步骤"><a href="#数据源的开发步骤" class="headerlink" title="数据源的开发步骤"></a>数据源的开发步骤</h2><ul><li>导入数据源的坐标和数据库驱动坐标</li><li>创建数据源对象</li><li>设置数据源的基本连接数据</li><li>使用数据源获取连接资源和归还连接资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动创建c3p0数据源</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     <span class="comment">//创建数据源</span></span><br><span class="line">     ComboPooledDataSource dataSource=<span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">     <span class="comment">//设置基本的连接参数</span></span><br><span class="line">     dataSource.setDriverClass(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">     dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/reggie?      serverTimezone=Asia/Shanghai&amp;userUnicode=true&amp;characterEncoding=utf-8&quot;</span>);</span><br><span class="line">     dataSource.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">     dataSource.setPassword(<span class="string">&quot;ssy971228&quot;</span>);</span><br><span class="line">     <span class="comment">//获取资源</span></span><br><span class="line">     Connection connection= dataSource.getConnection();</span><br><span class="line">     System.out.println(connection);</span><br><span class="line">     <span class="comment">//关闭</span></span><br><span class="line">     connection.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动创建Druid数据源</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     <span class="comment">//创建数据源</span></span><br><span class="line">     <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//设置基本的连接参数</span></span><br><span class="line">     dataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">     dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&amp;userUnicode=true&amp;characterEncoding=utf-8&quot;</span>);</span><br><span class="line">     dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">     dataSource.setPassword(<span class="string">&quot;ssy971228&quot;</span>);</span><br><span class="line">     <span class="comment">//获取资源</span></span><br><span class="line">     Connection connection= dataSource.getConnection();</span><br><span class="line">     System.out.println(connection);</span><br><span class="line">     <span class="comment">//关闭</span></span><br><span class="line">     connection.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>解耦方法：将数据库的Driver、URL、username、password全部写入配置文件中，之后进行修改的时候就可以 不用进入源码中进行修改，用键值对的方法进行，修改的代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过加载配置文件创建c3p0数据源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//读取配置文件ResourceBundle是专门用来处理properties文件的，因此文件名可以不用写扩展名。路径是相对resource的</span></span><br><span class="line">        ResourceBundle rb=ResourceBundle.getBundle(<span class="string">&quot;jdbc&quot;</span>);</span><br><span class="line">        String Driver=rb.getString(<span class="string">&quot;jdbc.driver&quot;</span>);</span><br><span class="line">        String url=rb.getString(<span class="string">&quot;jdbc.url&quot;</span>);</span><br><span class="line">        String username=rb.getString(<span class="string">&quot;jdbc.username&quot;</span>);</span><br><span class="line">        String password=rb.getString(<span class="string">&quot;jdbc.password&quot;</span>);</span><br><span class="line">        <span class="comment">//创建数据源对象</span></span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        <span class="comment">//设置相应配置</span></span><br><span class="line">        dataSource.setDriverClass(Driver);</span><br><span class="line">        dataSource.setJdbcUrl(url);</span><br><span class="line">        dataSource.setUser(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Spring配置数据源-1"><a href="#Spring配置数据源-1" class="headerlink" title="Spring配置数据源"></a>Spring配置数据源</h2><p>创建数据源对象以及设置相应配置这两个步骤可以交由Spring来进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试spring容器产生数据源对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       ApplicationContext app=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">       <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> app.getBean(DataSource.class);</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">       System.out.println(connection);</span><br><span class="line">       connection.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中xml的配置为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--name对应的setDriverClass-&gt;driverClass是set后面的方法名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>userUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ssy971228&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="抽取jdbc配置文件"><a href="#抽取jdbc配置文件" class="headerlink" title="抽取jdbc配置文件"></a>抽取jdbc配置文件</h2><p>application.xml加载jdbc.properties配置文件获得连接信息。首先需要引入context命名空间和约束路径</p><ul><li>命名空间</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br></pre></td></tr></table></figure><ul><li>约束路径：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载外部的properties文件--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--value的值用el表达式，因为配置文件已经加载进来了--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="spring注解开发"><a href="#spring注解开发" class="headerlink" title="spring注解开发"></a>spring注解开发</h1><h2 id="原始注解"><a href="#原始注解" class="headerlink" title="原始注解"></a>原始注解</h2><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，直接代替xml配置文件可以简化配置，提高开发效率。</p><p>spring原始注解主要是代替<Bean>的配置</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>使用在类上用于实例化Bean</td></tr><tr><td>@Controller</td><td>使用在web层类上类用于实例化Bean</td></tr><tr><td>@Service</td><td>使用在service层类上用于实例化Bean</td></tr><tr><td>@Repository</td><td>使用在dao层类上用于实例化Bean</td></tr><tr><td>@Autowired</td><td>使用在字段上用于根据类型依赖注入</td></tr><tr><td>@Qualifier</td><td>结合@Autowired一起使用用于根据名称进行依赖注入</td></tr><tr><td>@Resource</td><td>相当于@Autowired+@Qualifier，按照名称进行注入</td></tr><tr><td>@Value</td><td>注入普通属性</td></tr><tr><td>@Scope</td><td>标注Bean的作用范围，singleton&#x2F;prototype</td></tr><tr><td>@PostConstruct</td><td>使用在方法上标注该方法是Bean的初始化方法</td></tr><tr><td>@PreDestroy</td><td>使用在方法上标注该方法是Bean的销毁方法</td></tr></tbody></table><ul><li><font color="red"><strong>@Component</strong></font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;bean id=&quot;userDao&quot; class=&quot;com.learn.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="comment">//@Component(&quot;userdao&quot;)//@Component就代替上面那一行的配置，id的标志的话对应括号中的内容</span></span><br><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span><span class="comment">//因为是dao层的bean所以可以用Repository代替Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font color="red"><strong>@Autowired+@Qualifier</strong></font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;bean id=&quot;userService&quot; class=&quot;com.learn.service.impl.UserServiceImpl&quot;&gt;</span></span><br><span class="line"><span class="comment">//@Component(&quot;userService&quot;)</span></span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">   <span class="comment">//&lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span></span><br><span class="line">    <span class="comment">//@Autowired //数据的注入，默认按照数据类型从spring容器中进行匹配的，因此@Qualifier可以省略不写。但是userDao有多个bean就不行了</span></span><br><span class="line">    <span class="comment">//@Qualifier(&quot;userDao&quot;)//根据名称进行依赖的注入，括号中填写的是需要注入的bean的id。并且要结合Autowired一起使用</span></span><br><span class="line">  <span class="meta">@Resource(name=&quot;userDao&quot;)</span><span class="comment">//相当于@Autowired+@Qualifier</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">  <span class="comment">//使用注解的方式，set方法可以不用写。但是用配置文件set方法就必须要写  </span></span><br><span class="line">  <span class="comment">/*public void setUserDao(UserDao userDao) &#123;</span></span><br><span class="line"><span class="comment">        this.userDao = userDao;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>xml文件中需要添加组件扫描的配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.learn&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>@Value</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法一</span></span><br><span class="line"><span class="meta">@Value(&quot;itcast&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String driver;</span><br><span class="line"><span class="comment">//用法二,同样在xml中需要配置加载外部properties文件</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br></pre></td></tr></table></figure><h2 id="Spring新注解"><a href="#Spring新注解" class="headerlink" title="Spring新注解"></a>Spring新注解</h2><p>使用上面的注解还不能全部替代xml配置文件，还需要使用注解代替的配置如下：</p><ul><li>非自定义的Bean的配置<code>&lt;bean&gt;</code></li><li>加载properties文件的配置<code>&lt;context:property-placeholder&gt;</code></li><li>组件扫描的配置<code>&lt;context:component-scan&gt;</code></li><li>引入其他文件<code>&lt;import&gt;</code></li></ul><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Configuration</td><td>用于指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解</td></tr><tr><td>@ComponentScan</td><td>用于指定spring在初始化容器时要扫描的包。</td></tr><tr><td>@Bean</td><td>使用在<font color="red"><strong>方法</strong></font>上，标注将该方法的返回值存储到spring容器中</td></tr><tr><td>@PropertySource</td><td>用于加载.properties文件中的配置</td></tr><tr><td>@Import</td><td>用于导入其他配置类</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标志着该类是spring的核心配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//&lt;context:component-scan base-package=&quot;com.learn&quot;/&gt;配置扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.learn&quot;)</span></span><br><span class="line"><span class="comment">//&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="comment">//&lt;import resource=&quot;&quot;/&gt;引入其他模块的配置文件,并且可以配置多个</span></span><br><span class="line"><span class="comment">//@Import(&#123;DataSourceConfiguration.class,xxx.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span><span class="comment">//Spring会将当前方法的返回值以指定名称存储到spring容器中</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">        <span class="comment">//创建数据源</span></span><br><span class="line">        ComboPooledDataSource dataSource=<span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        <span class="comment">//设置基本的连接参数</span></span><br><span class="line">        dataSource.setDriverClass(driver);</span><br><span class="line">        dataSource.setJdbcUrl(url);</span><br><span class="line">        dataSource.setUser(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="spring整合Junit"><a href="#spring整合Junit" class="headerlink" title="spring整合Junit"></a>spring整合Junit</h1><p>在测试类中，每个测试方法都有以下两行代码，这两行代码的作用是获取容器，如果不写的话，直接回提示空指针异常。所以有不能轻易删掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);<span class="comment">//使用注解开发的</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> app.getBean(UserService.class);</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><ul><li>让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它。</li><li>将需要进行的测试Bean直接在测试类中进行注入。</li></ul><p>Spring集成Junit的步骤</p><ol><li>导入Spring集成junit的坐标</li><li>使用@Runwith直接替换原来的运行期</li><li>使用@ContextConfiguration指定配置文件或配置类</li><li>使用@Autowired注入需要测试的对象</li><li>创建测试方法进行测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)用的配置文件的方式</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span><span class="comment">//用的全注解的方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring与web环境集成"><a href="#Spring与web环境集成" class="headerlink" title="Spring与web环境集成"></a>Spring与web环境集成</h1><h2 id="ApplicationContext应用上下问获取方式"><a href="#ApplicationContext应用上下问获取方式" class="headerlink" title="ApplicationContext应用上下问获取方式"></a>ApplicationContext应用上下问获取方式</h2><p><strong>在Web项目中</strong>，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获取应用上下文ApplicationContext对象了。</p><ul><li>创建监听器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextLoaderListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line">          <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> servletContextEvent.getServletContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化上下文时，初始化applicationContext</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextConfigLocation</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;contextConfigLocation&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从web.xml中读取全局参数，</span></span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(contextConfigLocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将spring的应用上下文对象存储到ServletContext域中</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;app&quot;</span>,app);</span><br><span class="line">        System.out.println(<span class="string">&quot;spring容器创建完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>web层获取apllication上下文代码修改为</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//这一句已经在servlet中创建了</span></span><br><span class="line">        <span class="comment">// ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ServletContext servletContext = this.getServletContext();也可以这样写</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> req.getServletContext();<span class="comment">//获取servletcontext</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> (ApplicationContext) servletContext.getAttribute(<span class="string">&quot;app&quot;</span>);<span class="comment">//获取之间在servletcontext存储的app</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> app.getBean(UserService.class);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在web.xml中需要配置监听器,并且进行全局初始化配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置监听器--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.learn.listener.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--全局初始化参数--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring-提供获取应用上下文的工具"><a href="#Spring-提供获取应用上下文的工具" class="headerlink" title="Spring 提供获取应用上下文的工具"></a>Spring 提供获取应用上下文的工具</h2><p>​上面的代码不用手动实现，spring提供了一个监听器ContextLoaderListener就是对应上述功能的封装，该监听器内部加载spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApllicationContextUtils供使用者获得应用上下文对象。</p><ol><li><p>在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置spring提供的ContextLoaderListener监听器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--全局初始化参数--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="comment">&lt;!--classpath是指相应的路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用WebApplicationUtils获得应用上下文对象ApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> req.getServletContext();<span class="comment">//获取servletcontext</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> app.getBean(UserService.class);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h1><h2 id="SpringMVC开发步骤："><a href="#SpringMVC开发步骤：" class="headerlink" title="SpringMVC开发步骤："></a>SpringMVC开发步骤：</h2><ul><li>导入SpringMVC相关坐标</li><li>配置SpringMVC核心控制器DispathcerServlet</li></ul><p></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC的前端控制器--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span><span class="comment">&lt;!--告诉前端控制器，springmvc配置文件在哪里--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span><span class="comment">&lt;!--服务器启动时就创建对象--&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!--/表示缺省意味着任何请求都要走这个servlet--&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>创建Controller类和视图页面</li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span><span class="comment">//bean的controller层注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//请求映射</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;controllerService running....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用注解配置Controller类中业务方法的映射地址</li><li>配置SpringMVC核心配置文件spring-mvc.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Controller组件扫描,只扫描controller层--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.learn.controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>客户端发起请求测试</li></ul><h2 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h2><ol><li>用户发送请求只前端控制器DispatchServlet</li><li>DispatchServlet收到请求调用HandlerMapping处理器映射器</li><li>处理器映射器找到具体图的处理器（可以根据xml配置、注解进行查找），生成处理器对象及处理器拦截器（如果有则生成）一并返回给DispatchServlet</li><li>DispatchServlet调用HandlerAdapter处理器适配器</li><li>HandlerAdapte经过适配调用具体的处理器（controller，也叫后端控制器）</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapte将controller执行结果ModelAndView返回给DispatchServlet</li><li>DispatchServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析够返回具体View</li><li>DispatchServlet根据View进行渲染仕图（即将模型数据填充至视图中），DispatchServlet响应用户</li></ol><h2 id="SpringMVC的相关组件"><a href="#SpringMVC的相关组件" class="headerlink" title="SpringMVC的相关组件"></a>SpringMVC的相关组件</h2><ol><li>前端控制器：DispatcherServlet</li><li>处理映射器：HandlerMapping</li><li>处理适配器：HandlerAdapter</li><li>处理器：Handler（可以理解为Controller）</li><li>视图解析器：View Resolver</li><li>视图：View</li></ol><h2 id="SpringMVC的注解和配置"><a href="#SpringMVC的注解和配置" class="headerlink" title="SpringMVC的注解和配置"></a>SpringMVC的注解和配置</h2><ul><li><p><font color="red">@RequestMapping</font></p><p>作用：用于建立请求URL和处理请求方法之间的对应关系</p><p>位置：</p><ul><li>类上，请求URL的第一级访问目录，此处不写的话，相当于应用的根目录</li><li>方法上，请求URL的第二级访问目录，与类上的使用@RequestMapping标注的一级目录一起组成访问虚拟路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/xxx&quot;)</span><span class="comment">//可以用于确定是那个模块的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//请求映射</span></span><br><span class="line">    <span class="comment">//请求路径 http://localhost:8080/xxx/quick</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;controllerService running....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;<span class="comment">//这里加/表示是在web应用下进行资源的查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>value：用于指定请求的URL，它和path属性的作用是一样的</li><li>method：用于指定请求的方式</li><li>params：用于指定限制请求参数的条件，它支持简单的表达式。要求请求参数数的key和value必须和配置的一模一样</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping(value = &quot;/quick&quot;,method = RequestMethod.GET,params = &#123;&quot;username&quot;&#125;)</span></span><br><span class="line"><span class="comment">//访问路径http://localhost:8080/xxx/quick?username=xxx</span></span><br></pre></td></tr></table></figure></li><li><p>组件扫描</p><p>SpringMVC基于Spring容器，所以进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，需要进行组件的扫描</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--Controller组件扫描,只扫描controller层--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.learn.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Controller组件扫描的另一种写法，表示扫描com.learn包下面的Controller的注解--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.learn&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>MVC的视图解析器的配置解析(可以不用，内部本来就有)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置内部资源视图解析器--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--使用bean的依赖注入 /jsp/success.jsp--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/jsp/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="SpringMVC的数据响应"><a href="#SpringMVC的数据响应" class="headerlink" title="SpringMVC的数据响应"></a>SpringMVC的数据响应</h1><h2 id="SpringMVC的数据响应方式"><a href="#SpringMVC的数据响应方式" class="headerlink" title="SpringMVC的数据响应方式"></a>SpringMVC的数据响应方式</h2><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><ul><li><h4 id="直接返回字符串"><a href="#直接返回字符串" class="headerlink" title="直接返回字符串"></a>直接返回字符串</h4><p>此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转。</p><p>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">quickMethod</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视图解析器配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置内部资源视图解析器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--使用bean的依赖注入 /jsp/success.jsp--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/jsp/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><font color="red">转发资源地址为：&#x2F;jsp&#x2F;index.jsp</font></p><p><strong>返回带有前缀的字符串：</strong></p><p>​转发：forward：&#x2F;jsp&#x2F;index.jsp</p><p>​重定向：redirect：&#x2F;index.jsp</p></li><li><h4 id="通过ModelAndView对象返回"><a href="#通过ModelAndView对象返回" class="headerlink" title="通过ModelAndView对象返回"></a>通过ModelAndView对象返回</h4><p>SpringMVC可以根据方法的参数来进行数据的注入，因此ModelAndView可以自己创建也可以通过参数让Spring来进行数据的注入。</p><p>方式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick2&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ModelAndView <span class="title function_">sav2</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">/*model 作用封装数据</span></span><br><span class="line"><span class="comment">       * view  作用展示数据*/</span></span><br><span class="line">      ModelAndView modelAndView=<span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">      <span class="comment">//设置模型数据，前端页面使用el表达式来获取$&#123;username&#125;</span></span><br><span class="line">       modelAndView.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">      <span class="comment">//设置视图名称</span></span><br><span class="line">       modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> modelAndView;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">save3</span><span class="params">(ModelAndView modelAndView)</span>&#123;</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;learn&quot;</span>);</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法三：封装数据，视图通过字符串来进行返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick4&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save3</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;shangshuyu&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="回写数据"><a href="#回写数据" class="headerlink" title="回写数据"></a>回写数据</h3><ul><li><h4 id="直接返回字符串-1"><a href="#直接返回字符串-1" class="headerlink" title="直接返回字符串"></a>直接返回字符串</h4><p>web基础阶段，客户端访问服务器端，如果想直接回写字符串作为响应体返回的话，只需要使用respondse.getWrite().print(“hello world”)即可。那么在Controller中应该这么做</p><ul><li><p>通过SpringMVC框架注入response对象，使用response.getWrite().print(“hello world”)回写数据，此时不需要视图跳转，业务方法返回值为void</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    response.getWriter().println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick7&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 不进行视图跳转直接进行数据响应</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">quickMethod2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><font color="red">放回json数据</font> 利用json工具进行数据的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick9&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 不进行视图跳转直接进行数据响应</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">quickMethod4</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      user.setUsername(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">      user.setAge(<span class="number">18</span>);</span><br><span class="line">      <span class="comment">//使用json的转换工具将对象转换成json格式字符串在返回</span></span><br><span class="line">        ObjectMapper objectMapper=<span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        String json=objectMapper.writeValueAsString(user);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>需要在pom文件中导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--json转化工具--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="返回对象或集合"><a href="#返回对象或集合" class="headerlink" title="返回对象或集合"></a>返回对象或集合</h4><ul><li><p>方法一</p><p>通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc中进行配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick10&quot;)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 不进行视图跳转直接进行数据响应</span></span><br><span class="line">   <span class="comment">//希望springmvc自动将user转换成json格式的字符串</span></span><br><span class="line">   <span class="keyword">public</span> User <span class="title function_">quickMethod5</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">       user.setUsername(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">       user.setAge(<span class="number">18</span>);</span><br><span class="line">       <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在配置文件spring-mvc中需要添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置处理器映射器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;requestMappingHandlerAdapter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--使用bean的依赖注入 参数是List&lt;HttpMessageConverter&lt;?&gt;&gt;--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>方法二. <font color="red"><strong>替代注解处理器和适配器的配置</strong></font></p><p>在SpringMVC的各个组件中，<font color="4465AF"><strong>处理器映射器，处理器适配器，视图解析器</strong></font>成为SpringMVC的三大组件。使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>自动加载RequestMappingHandlerMapping（处理器映射器）和RequestMappingHandlerAdapter（处理器适配器），可用在Spring-mvc.xml配置文件中<font color="red"><strong>替代注解处理器和适配器的配置</strong></font>。同时使用默认底层就会集成jackson进行对象或集合的json格式字符串的转化。</p></li></ul></li></ul><p>​</p><h2 id="SpringMVC获得请求数据"><a href="#SpringMVC获得请求数据" class="headerlink" title="SpringMVC获得请求数据"></a>SpringMVC获得请求数据</h2><p>获得请求参数</p><p>客户端请求参数的格式是：name&#x3D;value&amp;name&#x3D;value…</p><p>服务器端要获得请求的参数，有时需要进行数据的封装，SpringMVC可以接受如下类型的参数：</p><h3 id="基本类型参数"><a href="#基本类型参数" class="headerlink" title="基本类型参数"></a>基本类型参数</h3><p>Controller中的业务方法的参数名称要与请求参数的name一直，参数值会自动映射匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://localhost:8080/spring_mvc/quick11?username=zhangsan&amp;age=12 访问地址</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/quick11&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//不进行页面跳转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quick11</span><span class="params">(String username,<span class="type">int</span> age)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       System.out.println(username);</span><br><span class="line">       System.out.println(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="POJO类型参数"><a href="#POJO类型参数" class="headerlink" title="POJO类型参数"></a>POJO类型参数</h3><p>Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数会自动映射匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://localhost:8080/spring_mvc/quick12?username=zhangsan&amp;age=12 访问地址</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/quick12&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//不进行页面跳转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quick12</span><span class="params">(User user)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   System.out.println(user);<span class="comment">//spring会进行自动封装</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组类型参数"><a href="#数组类型参数" class="headerlink" title="数组类型参数"></a>数组类型参数</h3><p>Controller中的业务方法数组名称宇请求参数的name一致，参数会自动映射匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://localhost:8080/spring_mvc/quick13?strs=111&amp;strs=222&amp;strs=333 访问地址</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick13&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span><span class="comment">//不进行页面跳转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quick13</span><span class="params">(String[] strs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(Arrays.asList(strs));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="集合类型参数"><a href="#集合类型参数" class="headerlink" title="集合类型参数"></a>集合类型参数</h3><p>获得集合参数时，要将集合参数包装到一个POJO中才可以。</p><p><strong>方法一：</strong>将集合包装成一个对象来进行获取</p><ul><li><p>将集合封装成一个vo对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; userList;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;VO&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userList=&quot;</span> + userList +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表单上需要表明是第几个对象的什么属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--action属性表明这个表单需要提交到哪里去--%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/spring_mvc/xxx/quick14&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    &lt;%--表明是第几个user对象的username age--%&gt;</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userList[0].username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userList[0].age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userList[1].username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userList[1].age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>后台接收数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick14&quot;)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span><span class="comment">//不进行页面跳转</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quick14</span><span class="params">(VO vo)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       System.out.println(vo);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>方法二：</strong>当使用ajax提交时，可以指定contextType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装</p><ul><li><p>页面上使用ajax的方式向后台发送数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> userList=<span class="keyword">new</span> <span class="title class_">Array</span>();</span></span><br><span class="line"><span class="language-javascript">userList.<span class="title function_">push</span>(&#123;<span class="attr">username</span>:<span class="string">&quot;zhangsan&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;);</span></span><br><span class="line"><span class="language-javascript">userList.<span class="title function_">push</span>(&#123;<span class="attr">username</span>:<span class="string">&quot;lisi&quot;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;);</span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">$.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">url</span>:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/xxx/quick15&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>:<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(userList),</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">contentType</span>:<span class="string">&quot;application/json;charset=utf-8&quot;</span></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>后台接收数据的时候就可以使用List<User> userList这个参数，但是需要使用**@RequsetBody**注解来说明接收的数据为json格式的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/quick15&quot;)</span><br><span class="line">@ResponseBody//不进行页面跳转</span><br><span class="line">public void quick15(@RequestBody List&lt;User&gt; userList)&#123;</span><br><span class="line">    System.out.println(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="请求数据乱码问题"><a href="#请求数据乱码问题" class="headerlink" title="请求数据乱码问题"></a>请求数据乱码问题</h2><p>当post请求是，数据会出现乱码问题，我们可以在<strong>web.xml</strong>中设置一个过滤器来进行编码的过滤。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置一个全局过滤的filter--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!--表示对所有资源进行过滤--&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参数绑定注解-requestParam"><a href="#参数绑定注解-requestParam" class="headerlink" title="参数绑定注解@requestParam"></a>参数绑定注解@requestParam</h2><p>当请求的名称与Controller的业务方法名称不一致时，就需要通过@RequestParam注解显示的绑定。属性值value写的是客户端请求时的参数名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://localhost:8080/spring_mvc/xxx/quick16?name=zhangsan  控制台也能输出zhangsan    </span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/quick16&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span><span class="comment">//不进行页面跳转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quick16</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String username)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>@RequestParam的参数有如下几种：</p><ul><li>value：请求参数名称</li><li>required：在此指定的请求参数是否必须包括。默认是true，提交时必须要有这个参数，如果没有此参数则报错</li><li>defaultValue：当没有指定请求参数时，则使用指定的默认值赋值</li></ul><h2 id="获得Restful风格的参数"><a href="#获得Restful风格的参数" class="headerlink" title="获得Restful风格的参数"></a>获得Restful风格的参数</h2><p>Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP协议里面四个表示操作方式的动词如下：</p><ul><li>GET:用于获取资源</li><li>POST：用于新建资源</li><li>PUT：用于更新资源</li><li>DELETE：用于删除资源</li></ul><img src="/Users/shuyushang/Library/Application Support/typora-user-images/image-20220527145918087.png" style="zoom:60%;" /> <p>上述url地址&#x2F;user&#x2F;1中的1就是要获取的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址&#x2F;user&#x2F;1可以写成&#x2F;user&#x2F;{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用**@PathVariable注解进行占位符的匹配获取工作**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//http://localhost:8080/spring_mvc/xxx/quick17/lisi</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/quick17/&#123;name&#125;&quot;)</span><span class="comment">//占位符的name要与PathVariable中的value值相匹配</span></span><br><span class="line">  <span class="meta">@ResponseBody</span><span class="comment">//不进行页面跳转</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quick17</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> String username)</span>  &#123;</span><br><span class="line">      System.out.println(username);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h2><p>SpringMVC默认已经提供了一些 常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置</p><p>但不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器</p><p>自定义类型转换器的开发步骤：</p><ul><li>定义转换器类实现Converter接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String,Date&gt; &#123;<span class="comment">//前面的范型是转换之前的类型，后面是转换成的类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">convert</span><span class="params">(String dateStr)</span> &#123;</span><br><span class="line">        <span class="comment">//将日期字符串转换成日期对象返回</span></span><br><span class="line">        SimpleDateFormat format=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);<span class="comment">//格式可以提成配置文件</span></span><br><span class="line">        Date date=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = format.parse(dateStr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在配置文件中声明转化器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明转换器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.converter.DateConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在&lt;annotation-deiven&gt;中引用转换器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mvc的注解驱动  conversion-service的值为转换器bean的id--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="获得servlet相关API"><a href="#获得servlet相关API" class="headerlink" title="获得servlet相关API"></a>获得servlet相关API</h2><p>SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，在想要获取参数的方法中将以下对象写成形参，常用的对象如下：</p><ul><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick19&quot;)</span><span class="comment">//这个方法是由框架进行调用，谁调用方法谁负责进行参数的注入</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quick19</span><span class="params">(HttpServletResponse response, HttpServletRequest request, HttpSession session)</span>  &#123;</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    System.out.println(request);</span><br><span class="line">    System.out.println(session);</span><br><span class="line">&#125;<span class="comment">//这三个对象是由tomcat原生产生的，传给springmvc框架，在调用方法时引用的传递</span></span><br></pre></td></tr></table></figure><h2 id="获得请求头"><a href="#获得请求头" class="headerlink" title="获得请求头"></a>获得请求头</h2><h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h3><p>使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name)。</p><p>@RequestHeader的注解属性如下：</p><ul><li>value：请求头名称，要与请求头名称一致</li><li>required：是否必须携带此请求头</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick20&quot;)</span><span class="comment">//这个方法是由框架进行调用，谁调用方法谁负责进行参数的注入</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quick20</span><span class="params">(<span class="meta">@RequestHeader(value = &quot;User-Agent&quot;,required = false)</span> String userAgent)</span>  &#123;</span><br><span class="line">    System.out.println(userAgent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h3><p>使用@CookieValue可以获得指定Cookie的值</p><p>@CookieValue注解的属性如下：</p><ul><li>value：指定cookie的名称</li><li>required：是否必须携带此cookie</li></ul><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ul><li><p>文件上传客户端三要素</p><ul><li>表单项type&#x3D;“file”</li><li>表单的提交方式是post</li><li>表单的enctype属性是多部分表单形式，及enctype&#x3D;“multipart&#x2F;form-data”</li></ul></li><li><p>文件上传的原理</p><ul><li>当form表单修改为多部分表单时，request.getParameter()将失效</li><li>enctype&#x3D;“application&#x2F;x-www-form-urlencoded”时，form表单的正文内容格式是：<font color="red">key&#x3D;value&amp;key&#x3D;value&amp;key&#x3D;value</font></li><li>当form表单的enctype取值为“multipart&#x2F;form-data”时，请求正文内容就变成了多部分形式。</li></ul></li></ul><p>![image-20220528161031221](&#x2F;Users&#x2F;shuyushang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220528161031221.png )</p><h4 id="单文件上传步骤"><a href="#单文件上传步骤" class="headerlink" title="单文件上传步骤"></a>单文件上传步骤</h4><p>①导入fileupload和io坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>②配置文件上传解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置文件上传的解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传文件的编码类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传总文件的大小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传单个文件的大小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSizePerFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;500000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>③编写文件上传代码</span><br></pre></td></tr></table></figure><p>③编写上传文件代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--前端页面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;./xxx/quick22&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    名称<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    文件<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;upload&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@RequestMapping(&quot;/quick22&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">//这里的形参名称要与前端页面的name保持一致，file类型java会封装成MultipartFile对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quick22</span><span class="params">(String username, MultipartFile upload)</span>  &#123;</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">//1.获得上传文件的名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> upload.getOriginalFilename();</span><br><span class="line">        <span class="comment">//2.将文件转存到</span></span><br><span class="line">        upload.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/shuyushang/Desktop/test/&quot;</span>+filename));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h4><ul><li>前端多文件上传时，name值不同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick23&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">//参数名与前端的参数名进行对应即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quick23</span><span class="params">(String username, MultipartFile upload,MultipartFile upload2)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="comment">//1.获得上传文件的名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> upload.getOriginalFilename();</span><br><span class="line">    <span class="comment">//2.将文件转存到</span></span><br><span class="line">    upload.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/shuyushang/Desktop/test/&quot;</span>+filename));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获得上传文件的名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filename2</span> <span class="operator">=</span> upload2.getOriginalFilename();</span><br><span class="line">    <span class="comment">//2.将文件转存到</span></span><br><span class="line">    upload.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/shuyushang/Desktop/test/&quot;</span>+filename2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>前端多文件上传时，name值一样的，后台用数组来接即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick23&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quick23</span><span class="params">(String username, MultipartFile[] upload)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile file : upload) &#123;</span><br><span class="line">        <span class="comment">//1.获得上传文件的名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">        <span class="comment">//2.将文件转存到</span></span><br><span class="line">        file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/shuyushang/Desktop/test/&quot;</span>+filename));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-JdbcTemplate基本使用"><a href="#Spring-JdbcTemplate基本使用" class="headerlink" title="Spring JdbcTemplate基本使用"></a>Spring JdbcTemplate基本使用</h1><h2 id="JdbcTemplate概述"><a href="#JdbcTemplate概述" class="headerlink" title="JdbcTemplate概述"></a>JdbcTemplate概述</h2><p>它是Spring框架中提供的一个对象，是对原始繁琐的jdbc api对象的简单封装，。spring框架为我们提供了很多的操作模版类。例如：操作关系型数据的jdbcTemplate和HibernateTemplate，操作nosql数据可的RedisTemplate，操作消息队列的JmsTemplate等等。</p><h2 id="JdbcTemplate开发步骤"><a href="#JdbcTemplate开发步骤" class="headerlink" title="JdbcTemplate开发步骤"></a>JdbcTemplate开发步骤</h2><ul><li>导入spring-jdbc和Spring-tx坐标</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>创建数据库表和实体</p></li><li><p>创建jdbcTemplate对象</p></li><li><p>执行数据库操作</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">       <span class="comment">//创建一个数据源对象</span></span><br><span class="line">       ComboPooledDataSource dataSource=<span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">       dataSource.setDriverClass(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">       dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/learn?serverTimezone=Asia/Shanghai&amp;userUnicode=true&amp;characterEncoding=utf-8&quot;</span>);</span><br><span class="line">       dataSource.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">       dataSource.setPassword(<span class="string">&quot;ssy971228&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();<span class="comment">//创建模版对象</span></span><br><span class="line">      <span class="comment">//设置数据源 知道数据源在哪</span></span><br><span class="line">       jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">       <span class="comment">//执行操作</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> jdbcTemplate.update(<span class="string">&quot;insert into account value (?,?)&quot;</span>, <span class="number">6000</span>,<span class="string">&quot;lily&quot;</span>);</span><br><span class="line">       System.out.println(row);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中ComboPooledDataSource，JdbcTemplate的对象都是调用的无参构造器都可以通过IOC进行数据的注入。</p><h3 id="简化后的步骤"><a href="#简化后的步骤" class="headerlink" title="简化后的步骤"></a>简化后的步骤</h3><ul><li>配置文件applicationContext，这三个配置之后配置数据源都是一起的！！<font color="red"><strong>背熟了</strong></font></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载jdbc.properties--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置ComboPooledDataSource的数据注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置JdbcTemplate的数据注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>测试代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*通过spring产生jdbcTemplate对象*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;ApplicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> app.getBean(JdbcTemplate.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> jdbcTemplate.update(<span class="string">&quot;insert into account value (?,?)&quot;</span>, <span class="number">8000</span>, <span class="string">&quot;mary&quot;</span>);</span><br><span class="line">    System.out.println(row);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h3><p> 如果查询出来的是个实体，需要使用new BeanPropertyRowMapper对实体进行封装。</p><p>更新操作：jdbcTemplate.update(sql,params)</p><p>查询操作：jdbcTemplate.query(sql, Mapper,params)</p><p>​jdbcTemplate.queryForObject(sql, Mapper,params)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span><span class="comment">//让测试运行于Spring测试环境</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:ApplicationContext.xml&quot;)</span><span class="comment">//引入配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateCRUDTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> jdbcTemplate.update(<span class="string">&quot;update account set money=? where name=?&quot;</span>, <span class="number">9000</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(row+<span class="string">&quot;更新操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> jdbcTemplate.update(<span class="string">&quot;delete from account where name=?&quot;</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(row+<span class="string">&quot;删除操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryAll</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Account&gt; list = jdbcTemplate.query(<span class="string">&quot;select * from account&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuerySingle</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;select * from account where name=?&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class), <span class="string">&quot;lily&quot;</span>);</span><br><span class="line">        System.out.println(account);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//查询总行数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;select count(*) from account&quot;</span>, Long.class);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring练习"><a href="#Spring练习" class="headerlink" title="Spring练习"></a>Spring练习</h1><ul><li>环境的搭建</li></ul><p>![image-20220529152750754](&#x2F;Users&#x2F;shuyushang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220529152750754.png)</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><p>主要配置一些bean，例如数据源的对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.配置数据源--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.1加载jdbc.properties--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.2配置数据源对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.3配置jdbcTemplate的对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="spring-mvc-xml"><a href="#spring-mvc-xml" class="headerlink" title="spring_mvc.xml"></a>spring_mvc.xml</h3><p>主要是配置一些注解驱动，内置视图解析器、静态资源的访问等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.配置数据源--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.1加载jdbc.properties--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.2配置数据源对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.3配置jdbcTemplate的对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><p>它主要的是用来配置欢迎页、servlet、filter、listener等以及定制servlet、JSP、Context初始化参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局的初始化参数--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--配置spring的监听器--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--springmvc的前端控制器--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring_mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="角色列表的展示步骤"><a href="#角色列表的展示步骤" class="headerlink" title="角色列表的展示步骤"></a>角色列表的展示步骤</h2><img src="/Users/shuyushang/Library/Application Support/typora-user-images/image-20220529182007045.png" alt="image-20220529182007045" style="zoom: 67%;" /><p>代码编写思路-&gt;Controller-&gt;Service接口-&gt;service实现类，这里需要调用dao层的接口-&gt;Dao层的接口-&gt;dao层的实现类，这里需要调用JdbcTemplate实现数据的查询。</p><p>之后需要使用注解方式将对应的对象存入Spring框架中，@Controller&#x2F;@Service&#x2F;@Repository，最后设置包扫描。</p><p>也可以将只使用@controller在spring-mvc中配置包扫描&lt;context:component-scan base-package&#x3D;”com.learn.controller”&#x2F;&gt;，service和dao层在applicationContext中配置bean</p><h2 id="用户登录权限控制（拦截器）"><a href="#用户登录权限控制（拦截器）" class="headerlink" title="用户登录权限控制（拦截器）"></a>用户登录权限控制（拦截器）</h2><p>用户在没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作。</p><p>判断用户到底是否登录，即判断session中是否有user对象</p><h1 id="Spring拦截器"><a href="#Spring拦截器" class="headerlink" title="Spring拦截器"></a>Spring拦截器</h1><h2 id="拦截器的作用"><a href="#拦截器的作用" class="headerlink" title="拦截器的作用"></a>拦截器的作用</h2><p>springmvc拦截器类似于servlet开发过程中的过滤器Filter，用于<font color="red"><strong>对处理器进行预处理和后处理</strong></font></p><p>将拦截器按一定的顺序联结成一条链，这条链称为拦截器链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用，<strong>拦截器也是AOP思想的具体实现。</strong></p><h2 id="拦截器和过滤器的区别"><a href="#拦截器和过滤器的区别" class="headerlink" title="拦截器和过滤器的区别"></a>拦截器和过滤器的区别</h2><table><thead><tr><th>区别</th><th>过滤器Filter</th><th>拦截器Interceptor</th></tr></thead><tbody><tr><td>使用范围</td><td>是servlet规范中的一部分，任何web工程都可以使用</td><td>是springmvc框架自己的，只有使用了Springmvc框架的工程才可以使用</td></tr><tr><td>拦截范围</td><td>在url-pattern中配置了&#x2F;*之后，可以对所要访问的资源拦截</td><td>在&lt;mvc:mapping path&#x3D;””&#x2F;&gt;配置了&#x2F;**之后，也可以对多有资源进行拦截，但是可以通过&lt;mvc:exculde-mapping path&#x3D;””&#x2F;&gt;标签排除不需要拦截的资源</td></tr></tbody></table><h2 id="拦截器快速入门"><a href="#拦截器快速入门" class="headerlink" title="拦截器快速入门"></a>拦截器快速入门</h2><ul><li>创建拦截器类实现HandlerInterceptor接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//在controller方法执行之前，执行该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle&quot;</span>);</span><br><span class="line">        <span class="comment">//return false;//这里返回false，后面的流程都不能继续执行了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//目标方法执行之后，视图返回之前，执行该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//在流程执行完毕之后，执行该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置拦截器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器 spring_mvc--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--对那些资源执行拦截操作 /**代表对所有资源进行拦截操作--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.interceptor.MyInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试拦截器的拦截效果</li></ul><h3 id="preHandle"><a href="#preHandle" class="headerlink" title="preHandle"></a>preHandle</h3><p>主要是在目标方法执行之前，运行该方法。返回值为boolean型。</p><p>返回flase表示不放行，后续目标方法久不能继续执行，可以通过request和response进行资源的重定向避免了目标资源。</p><p>返回true表示放行，可以继续执行目标方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;preHandle&quot;</span>);</span><br><span class="line">       <span class="comment">//return false;//这里返回false，后面的流程都不能继续执行了</span></span><br><span class="line">       <span class="comment">//localhost:8080/target?param=yes</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;param&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span>(<span class="string">&quot;yes&quot;</span>.equals(param))&#123;<span class="comment">//携带的参数如果是yes的话就放行</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//不是的yes的话，页面就跳转到error.jsp</span></span><br><span class="line">           request.getRequestDispatcher(<span class="string">&quot;/error.jsp&quot;</span>).forward(request,response);<span class="comment">//进行转发</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="postHandle"><a href="#postHandle" class="headerlink" title="postHandle"></a>postHandle</h3><p>其中有个modelAndView的参数可以将目标方法中的模型和视图进行修改在进行返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标方法执行之后，视图返回之前，执行该方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       modelAndView.addObject(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;ithema&quot;</span>);<span class="comment">//修改controller中modelAndView中携带的参数</span></span><br><span class="line">       System.out.println(<span class="string">&quot;postHandle&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="afterCompletion"><a href="#afterCompletion" class="headerlink" title="afterCompletion"></a>afterCompletion</h3><p>在流程执行之后，对异常进行封装。使用的比较少。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;!--对那些资源执行拦截操作 /**代表对所有资源进行拦截操作--&gt;</span><br><span class="line">        &lt;mvc:mapping path=&quot;/**&quot;/&gt;</span><br><span class="line">        &lt;bean class=&quot;com.learn.interceptor.MyInterceptor1&quot;/&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;!--对那些资源执行拦截操作 /**代表对所有资源进行拦截操作--&gt;</span><br><span class="line">        &lt;mvc:mapping path=&quot;/**&quot;/&gt;</span><br><span class="line">        &lt;bean class=&quot;com.learn.interceptor.MyInterceptor2&quot;/&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><p>![image-20220601170931664](&#x2F;Users&#x2F;shuyushang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220601170931664.png)</p><h3 id="拦截器链的执行顺序"><a href="#拦截器链的执行顺序" class="headerlink" title="拦截器链的执行顺序"></a>拦截器链的执行顺序</h3><p>与配置文件的顺序一致，先配置那个哪个的preHandle先执行，然后就是<strong>先去(pre)的后回(post,after)</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--对那些资源执行拦截操作 /**代表对所有资源进行拦截操作--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.interceptor.MyInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--对那些资源执行拦截操作 /**代表对所有资源进行拦截操作--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.interceptor.MyInterceptor2&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>对应的执行顺序：</strong>Pre1-&gt;pre2-&gt;目标方法-&gt;post2-&gt;post1-&gt;after2-&gt;after1</p><h1 id="Spring异常处理机制"><a href="#Spring异常处理机制" class="headerlink" title="Spring异常处理机制"></a>Spring异常处理机制</h1><p>系统中的异常包括两类：<font color="red"><strong>预期异常</strong></font>和<font color="red"><strong>运行时异常RuntimeException</strong></font>，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发，测试等手段减少运行时异常的发生。</p><p>系统的Dao、Service、Controller出现都通过throw Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理</p><p>![image-20220602125352768](&#x2F;Users&#x2F;shuyushang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220602125352768.png)</p><h2 id="异常处理的方式"><a href="#异常处理的方式" class="headerlink" title="异常处理的方式"></a>异常处理的方式</h2><h3 id="简单异常处理器"><a href="#简单异常处理器" class="headerlink" title="简单异常处理器"></a>简单异常处理器</h3><p>使用SpringMVC提供的简单异常处理器SimpleMappingExceptionResolver，SpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置spring异常处理器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultErrorView&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span><span class="comment">&lt;!--默认的异常--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">map</span>&gt;</span><span class="comment">&lt;!--key表示的是异常的类型  value表示错误视图--&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ClassCastException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error1&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;com.learn.exception.MyException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error2&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自定义异常处理器"><a href="#自定义异常处理器" class="headerlink" title="自定义异常处理器"></a>自定义异常处理器</h3><p>使用Spring的异常处理器接口HandlerExceptionResolver。自定义处理器的步骤：</p><ul><li>创建异常处理器类实现HandlerExceptionResolver</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionResolver</span>  <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> &#123;</span><br><span class="line">        <span class="comment">//参数Exception 异常对象   返回值ModelAndView表示要跳转的错误视图的信息</span></span><br><span class="line">        ModelAndView modelAndView=<span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> MyException)&#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;自定义异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> ClassCastException)&#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;转换类型异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置异常处理器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置自定义异常处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.resolver.MyExceptionResolver&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写异常页面</li><li>测试异常跳转</li></ul><h1 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a>Spring的AOP</h1><h2 id="AOP的简介"><a href="#AOP的简介" class="headerlink" title="AOP的简介"></a>AOP的简介</h2><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h3><p>AOP为Aspect Oriented Programming的缩写，意思为<font color="red"><strong>面向切面编程</strong></font>，是通过预编译的放肆和运行起动态代理实现程序功能的统一维护的一种技术。（切面：目标方法+增强功能）</p><p>利用<strong>AOP可以对业务逻辑的各个部分进行隔离</strong>，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><h3 id="AOP的作用及其优势"><a href="#AOP的作用及其优势" class="headerlink" title="AOP的作用及其优势"></a>AOP的作用及其优势</h3><ul><li>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强</li><li>优势：减少重复代码，提高开发效率，并且便于维护</li></ul><h3 id="AOP的底层实现"><a href="#AOP的底层实现" class="headerlink" title="AOP的底层实现"></a>AOP的底层实现</h3><p>AOP的底层是通过Spring提供的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p><h3 id="AOP的动态代理技术"><a href="#AOP的动态代理技术" class="headerlink" title="AOP的动态代理技术"></a>AOP的动态代理技术</h3><p>常用的动态代理技术</p><ul><li>JDK代理：基于接口的动态代理技术</li></ul><img src="/Users/shuyushang/Library/Application Support/typora-user-images/image-20220611144911518.png" alt="image-20220611144911518" style="zoom:50%;" /><ul><li>cglib代理：基于父类的动态代理技术</li></ul><img src="/Users/shuyushang/Library/Application Support/typora-user-images/image-20220611144948233.png" alt="image-20220611144948233" style="zoom:50%;" /><h3 id="基于jdk的动态代理"><a href="#基于jdk的动态代理" class="headerlink" title="基于jdk的动态代理"></a>基于jdk的动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        <span class="keyword">final</span> Target target=<span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得增强对象</span></span><br><span class="line">        <span class="keyword">final</span> Advice advice=<span class="keyword">new</span> <span class="title class_">Advice</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回值 就是动态生成的代理对象</span></span><br><span class="line">        TargetInterface proxy=(TargetInterface)Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">//目标对象加载器</span></span><br><span class="line">                target.getClass().getInterfaces(),<span class="comment">// 目标对象相同的接口字节码对象数组</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="comment">//调用代理对象的任何方法，实质执行的都是invoke方法</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">//前置增强</span></span><br><span class="line">                        advice.before();</span><br><span class="line">                        <span class="comment">//执行目标方法</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                        <span class="comment">//后置增强</span></span><br><span class="line">                        advice.after();</span><br><span class="line">                        <span class="keyword">return</span> invoke;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//调用代理对象的方法</span></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于cglib的动态代理"><a href="#基于cglib的动态代理" class="headerlink" title="基于cglib的动态代理"></a>基于cglib的动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        <span class="keyword">final</span> Target target=<span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得增强对象</span></span><br><span class="line">        <span class="keyword">final</span> Advice advice=<span class="keyword">new</span> <span class="title class_">Advice</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回值 就是动态生成的代理对象 基于cglib</span></span><br><span class="line">        <span class="comment">//1、创建增强器</span></span><br><span class="line">        Enhancer enhancer=<span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、设置父类（目标）</span></span><br><span class="line">        enhancer.setSuperclass(Target.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="comment">//执行前置</span></span><br><span class="line">                advice.before();</span><br><span class="line">                <span class="comment">//执行目标</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                <span class="comment">//执行后置</span></span><br><span class="line">                advice.after();</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//4、创建代理对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target) enhancer.create();</span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h3><ul><li>Target（目标对象）：代理的目标对象</li><li>Proxy（代理）：一个类被AOP织入增强后，就产生一个代理类</li><li>Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。可以被增强的方法叫做连接点。</li><li>Pointcut（切入点）：是指我们要对那些Joinpoint进行拦截的定义。</li><li>Advice（通知&#x2F;增强）：是指拦截到Joinpoint之后所要做的事情就是通知。（就是增强的逻辑）</li><li>Aspect（切面）：是切点和通知的结合</li><li>Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。Spring采用动态代理织入，而Aspect采用编译期织入和类装载期织入。-&gt;就是将切点与增强结合在一起的过程就叫织入</li></ul><h3 id="AOP开发明确的事项"><a href="#AOP开发明确的事项" class="headerlink" title="AOP开发明确的事项"></a>AOP开发明确的事项</h3><ol><li><p>需要编写的内容</p><ul><li>编写核心业务代码（目标类的目标方法）</li><li>编写切面类，切面类中有通知（增强功能方法）</li><li>在配置文件中，配置织入关系，即将那些通知与那些连接点进行结合</li></ul></li><li><p>AOP技术实现的内容</p><p>Spring框架监控切入点方法的执行，一旦监控到切点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p></li><li><p>AOP底层使用哪种代理方式</p><p>在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式</p></li></ol><p>​</p><h2 id="基于XML的AOP开发"><a href="#基于XML的AOP开发" class="headerlink" title="基于XML的AOP开发"></a>基于XML的AOP开发</h2><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ul><li>导入AOP相关坐标-&gt;目前Spring已经集成了，所以导入一个spring-context，此外还需要导入aspectjweaver</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!--aspectj对aop的实现比Spring的要好，更加轻便--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>创建目标接口和目标类（内部有切点）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建切面类（内部有增强方法）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将目标类和切面类的对象创建权交给spring-&gt;使用spring的IOC容器去托管这些对象</li><li>在applicationContext.xml中配置织入关系</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--目标对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.aop.Target&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--切面对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.aop.MyAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置织入 告诉Spring框架那些方法《切点》需要进行那些增强（前置、后置）--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.引入aop的命名空间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.声明切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切面：切点+通知 那个切点(pointcut)需要怎么样的增强(aop:before)是那个增强方法(method)）--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--aop：before 增强的类型/通知的类型--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--method 切面（myAspect）中的方法名称--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--pointcut 起点表达式，可以一次性指定多个方法--&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public void com.learn.aop.Target.save())&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.learn.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--aop包下的任意类的任意方法要被增强--&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopTest</span> &#123;</span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TargetInterface target;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">         target.save();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切点表达式的写法"><a href="#切点表达式的写法" class="headerlink" title="切点表达式的写法"></a>切点表达式的写法</h3><p>表达式语法</p><p><code>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</code></p><ul><li>访问修饰符可以省略不写</li><li>返回值类型、包名、类名、方法名可以使用星号*代表任意</li><li>包名与类名之间一个点，代表当前包下的类，两个点..表示当前包及其子包下的类</li><li>参数列表可以使用两个点..表示任意个数，任意类型的参数列表</li></ul><p>![image-20220613183049116](&#x2F;Users&#x2F;shuyushang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220613183049116.png)</p><ul><li>返回值：void    包名：com.itheima.aop   类名：Target  方法名：method  参数：无</li><li>返回值：void    包名：com.itheima.aop   类名：Target  方法名：任意方法  参数：任意个数</li><li>返回值：任意类型    包名：com.itheima.aop   类名：aop包下的任意类  方法名：任意方法  参数：任意个数</li><li>返回值：任意类型    包名：com.itheima.aop   类名：aop包及其子包下的任意类  方法名：任意方法  参数：任意个数</li><li>返回值：任意类型   任意包及其子包的任意类下的任意方法，参数任意个数</li></ul><h3 id="通知的类型"><a href="#通知的类型" class="headerlink" title="通知的类型"></a>通知的类型</h3><p>通知配置的语法：</p><p><code>&lt;aop:通知类型 method=“切面类中方法名 pointcut=”切点表达式“&gt;&lt;/aop:通知类型&gt;</code></p><table><thead><tr><th>名称</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>前置通知</td><td><code>&lt;aop:before&gt;</code></td><td>用于配置前置通知，指定增强的方法在切入点方法之前执行</td></tr><tr><td>后置通知</td><td><code>&lt;aop:after-returning&gt;</code></td><td>用于配置后置通知，指定增强的方法在切入点方法之后执行</td></tr><tr><td>环绕通知</td><td><code>&lt;aop:around&gt;</code></td><td>用于配置环绕通知，执行增强的方法在切入点方法之前和之后都执行</td></tr><tr><td>异常抛出通知</td><td><code>&lt;aop:throwing&gt;</code></td><td>用于配置异常抛出通知，指定增强的方法在出现异常时执行</td></tr><tr><td>最终通知</td><td><code>&lt;aop:after&gt;</code></td><td>用于配置最终通知，无论增强方法执行是否有异常都会执行</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afteReturnning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ProceedingJoinPoint:正在执行的连接点===切点</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">arounding</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前增强&quot;</span>);</span><br><span class="line">        <span class="comment">//添加目标方法（切点）</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后增强&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常排除增强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">After</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//不管抛不抛异常都要执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最终增强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="切点表达式的抽取"><a href="#切点表达式的抽取" class="headerlink" title="切点表达式的抽取"></a>切点表达式的抽取</h3><p>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用pointcut-ref属性代替pointcut属性来引用抽取后的切点表达式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--抽取切点表达式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.learn.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;arounding&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基于注解的AOP开发"><a href="#基于注解的AOP开发" class="headerlink" title="基于注解的AOP开发"></a>基于注解的AOP开发</h2><h3 id="开发步骤-1"><a href="#开发步骤-1" class="headerlink" title="开发步骤"></a>开发步骤</h3><ul><li><p>创建目标接口和目标类（内部有切点）</p></li><li><p>创建切面类（内部有增强方法）</p></li><li><p>将目标类和切面类的对象创建权交给spring</p><p>在目标类和切面类上都添加注解<code>@Component(&quot;名称&quot;)</code>相当于配置了bean，对于切面类还需要添加注解<code>@Aspect</code>来告诉Spring这个类是切面类</p></li><li><p>在切面类中使用注解配置织入关系</p><p>例如前置通知使用<code>@Before(&quot;execution(* com.learn.anno_aop.*.*(..)))</code>表示前置增强anno_aop包下的所有类的所有方法</p></li><li><p>在配置文件中开启组件扫描和AOP的自动代理</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启组件扫描--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.learn.anno_aop&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--aop的自动代理--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><h3 id="注解通知的类型"><a href="#注解通知的类型" class="headerlink" title="注解通知的类型"></a>注解通知的类型</h3><p>通知的配置语法<code>@通知注解(“切点表达式”)</code></p><table><thead><tr><th>名称</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>前置通知</td><td><code>@Before</code></td><td>用于配置前置通知，指定增强的方法在切入点方法之前执行</td></tr><tr><td>后置通知</td><td><code>@AfterReturning</code></td><td>用于配置后置通知，指定增强的方法在切入点方法之后执行</td></tr><tr><td>环绕通知</td><td><code>@Around</code></td><td>用于配置环绕通知，执行增强的方法在切入点方法之前和之后都执行</td></tr><tr><td>异常抛出通知</td><td><code>@AfterThrowing</code></td><td>用于配置异常抛出通知，指定增强的方法在出现异常时执行</td></tr><tr><td>最终通知</td><td><code>@After</code></td><td>用于配置最终通知，无论增强方法执行是否有异常都会执行</td></tr></tbody></table><h3 id="切点表达式的抽取-1"><a href="#切点表达式的抽取-1" class="headerlink" title="切点表达式的抽取"></a>切点表达式的抽取</h3><p>同xml配置aop一样，我们可以将切点表达式抽取。抽取方法是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在增强注解中进行引用。</p><p>引用切点表达式</p><ul><li>可以直接使用方法名<code> @Around(&quot;pointCut()&quot;)</code></li><li>使用类名.方法名<code>@AfterReturning(&quot;MyAspect.pointCut()&quot;)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;MyAspect.pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afteReturnning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Around(&quot;pointCut()&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">arounding</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前增强&quot;</span>);</span><br><span class="line">        <span class="comment">//添加目标方法（切点）</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后增强&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//定义切点表达式</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.learn.anno_aop.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring的事务控制"><a href="#Spring的事务控制" class="headerlink" title="Spring的事务控制"></a>Spring的事务控制</h1><h2 id="编程式事务控制相关对象"><a href="#编程式事务控制相关对象" class="headerlink" title="编程式事务控制相关对象"></a>编程式事务控制相关对象</h2><h3 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h3><p>PlatformTransactionManager接口是spring的事务管理器，它里面提供了我们常用的操作事务的方法</p><p>![image-20220614183929215](&#x2F;Users&#x2F;shuyushang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220614183929215.png)</p><p><font color="red"><strong>注意：</strong></font></p><p>PlatformTransactionManager是接口类型，<strong>不同的Dao层技术则有不同实现类</strong>例如：</p><ul><li>dao层技术是jdbc或者mybatis时 DataSourceTransactionManager</li><li>dao层技术是hibernate时 HibernateTransactionManager</li></ul><h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h3><p>TransactionDefinition是事务的定义信息对象</p><p>![image-20220614185005173](&#x2F;Users&#x2F;shuyushang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220614185005173.png)</p><h4 id="1-事务的隔离级别（lsolation-level）"><a href="#1-事务的隔离级别（lsolation-level）" class="headerlink" title="1.事务的隔离级别（lsolation level）"></a>1.事务的隔离级别（lsolation level）</h4><p>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重读或虚读</p><ul><li>ISOLATION_DEFAULT 默认</li><li>ISOLATION_READ_UNCOMMITTED</li></ul><p>​一个事务读取了另一个事务没有提交的数据</p><ul><li>ISOLATION_READ_COMMITTED</li></ul><p>​一个事务的操作结果只有等提交后，才能被另一个事务看到。这个是大部分数据库采用的默认隔离级别，它能解决脏读的问题，但是不能解决不可重复读和幻读的问题。</p><ul><li>ISOLATION_REPEATABLE_READ</li></ul><p>​这个隔离级别可以保证，在整个事务中，对于同一笔数据读取结果是相同的，不管其他事务对这个数据进行更新提交，对本事务来说没有影响。这个级别能解决脏读和不可重复读的问题，但是不能解决幻读的问题。</p><ul><li>ISOLATION_SERIALIZABLE</li></ul><p>​这个是最严格的级别。它能解决以上所有的问题，但缺点也狠明显，因为它解决问题的本质是让所有的事务操作都必须一次顺序进行，这样性能就会差到令人发指。也正是因为这样，这个隔离级别用到的场景极少。通常我们使用其他隔离级别加并发锁就可以实现这个级别的数据一致性，性能还远高于使用这个级别。</p><h4 id="2-事务的传播行为（Propagation-behavior）"><a href="#2-事务的传播行为（Propagation-behavior）" class="headerlink" title="2.事务的传播行为（Propagation behavior）"></a>2.事务的传播行为（Propagation behavior）</h4><ul><li>REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。默认值</li><li>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方法执行（没有事务）</li><li>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常</li><li>REQUIRES_NEW：新建事务，如果当前在事务中，把当前事务挂起</li><li>NOT_SUPPORTED：以非事务方法执行操作，如果当前存在事务，就把当前事务挂起</li><li>NEVER：以非事务方式运行，如果当前存在事务，抛出异常</li><li>NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED类似的操作。</li><li>超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置</li><li>是否只读：建议查询时设置为只读</li></ul><h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><p>TransactionStatus接口提供的是事务具体的运行状态，方法介绍如下：</p><p>![image-20220616124538507](&#x2F;Users&#x2F;shuyushang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220616124538507.png)</p><h2 id="基于XML的声明式事务控制"><a href="#基于XML的声明式事务控制" class="headerlink" title="基于XML的声明式事务控制"></a>基于XML的声明式事务控制</h2><h3 id="什么是声明式事务控制"><a href="#什么是声明式事务控制" class="headerlink" title="什么是声明式事务控制"></a>什么是声明式事务控制</h3><p>spring的声明式事务副名思义就是<font color="red">采用声明的方式来处理事务</font>。这里所说的声明，就是指在配置文件中声明，用在spring配置文件中声明式的处理事务代替代码式的处理事务</p><p><strong>声明式事务处理的作用</strong></p><ul><li><p>事务管理不侵入开发的组件。业务逻辑对象不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层米昂的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可。</p></li><li><p>在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便</p><p><font color="red"><strong>注意：Spring声明式事务控制底层就是AOP</strong></font></p></li></ul><h2 id="声明式事务控制的实现"><a href="#声明式事务控制的实现" class="headerlink" title="声明式事务控制的实现"></a>声明式事务控制的实现</h2><ul><li>谁是切点？</li><li>谁是通知？</li><li>配置织入？</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在业务实现层里面添加事务的控制--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--目标对象 内部的方法就是切点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置平台事务管理器transactionManager--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--通知 事务的增强--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置事务的aop织入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring概述&quot;&gt;&lt;a href=&quot;#Spring概述&quot; class=&quot;headerlink&quot; title=&quot;Spring概述&quot;&gt;&lt;/a&gt;Spring概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Spring是轻量级的开源的JavaEE框架&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://shininginfo.github.io/2022/06/25/hello-world/"/>
    <id>https://shininginfo.github.io/2022/06/25/hello-world/</id>
    <published>2022-06-25T07:11:40.417Z</published>
    <updated>2022-06-25T14:55:29.084Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
